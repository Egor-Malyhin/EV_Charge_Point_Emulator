package org.mycorp.commcsms;

import eu.chargetime.ocpp.feature.profile.ClientCoreEventHandler;
import eu.chargetime.ocpp.model.core.*;
import org.mycorp.models.events.commcsms.StopChargingByCSMS;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.stereotype.Component;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

//Implementation of the ClientCoreEventHandler interface
//from the eu.chargetime Java OCA-OCPP library.
//Handles requests initiated by the CSMS.
@Component
public class CSMSCommunicationBlockClientHandler implements ClientCoreEventHandler {
    private final ApplicationEventPublisher applicationEventPublisher;

    //Used CountDownLatch, since using CompletableFuture here is impractical,
    //since future will end immediately after calling publishEvent().
    private CountDownLatch countDownLatch;

    @Autowired
    public CSMSCommunicationBlockClientHandler(ApplicationEventPublisher applicationEventPublisher) {
        this.applicationEventPublisher = applicationEventPublisher;
        this.countDownLatch = new CountDownLatch(1);
    }

    //Since the CountDownLatch counter cannot be lowered in this method,
    //we recreate the CountDownLatch object.
    private void resetLatch() {
        countDownLatch = new CountDownLatch(1);
    }

    //When expanding the program, keep in mind that all event objects generated by this class
    //must contain a reference to the CountDownLatch object,
    //and also do not forget to use the resetLatch() method in finally block.
    @Override
    public RemoteStopTransactionConfirmation handleRemoteStopTransactionRequest(RemoteStopTransactionRequest remoteStopTransactionRequest) {
        try {
            applicationEventPublisher.publishEvent(new StopChargingByCSMS(countDownLatch));
            boolean isContinue = countDownLatch.await(2, TimeUnit.SECONDS);
            return new RemoteStopTransactionConfirmation(isContinue ? RemoteStartStopStatus.Accepted : RemoteStartStopStatus.Rejected);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        } finally {
            resetLatch();
        }
    }

    @Override
    public ChangeAvailabilityConfirmation handleChangeAvailabilityRequest(ChangeAvailabilityRequest changeAvailabilityRequest) {
        return null;
    }

    @Override
    public GetConfigurationConfirmation handleGetConfigurationRequest(GetConfigurationRequest getConfigurationRequest) {
        return null;
    }

    @Override
    public ChangeConfigurationConfirmation handleChangeConfigurationRequest(ChangeConfigurationRequest changeConfigurationRequest) {
        return null;
    }

    @Override
    public ClearCacheConfirmation handleClearCacheRequest(ClearCacheRequest clearCacheRequest) {
        return null;
    }

    @Override
    public DataTransferConfirmation handleDataTransferRequest(DataTransferRequest dataTransferRequest) {
        return null;
    }

    @Override
    public RemoteStartTransactionConfirmation handleRemoteStartTransactionRequest(RemoteStartTransactionRequest remoteStartTransactionRequest) {
        return null;
    }

    @Override
    public ResetConfirmation handleResetRequest(ResetRequest resetRequest) {
        return null;
    }

    @Override
    public UnlockConnectorConfirmation handleUnlockConnectorRequest(UnlockConnectorRequest unlockConnectorRequest) {
        return null;
    }
}
